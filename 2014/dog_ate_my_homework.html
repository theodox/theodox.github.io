<!DOCTYPE html>
<html lang="en">
<head>
          <title>Chimeras & Manticores</title>
        <meta charset="utf-8" />
        <link href="http://theodox.com/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Chimeras & Manticores Full Atom Feed" />
        <link href="http://theodox.com/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="Chimeras & Manticores Full RSS Feed" />



    <meta name="tags" content="programming" />
    <meta name="tags" content="python" />
    <meta name="tags" content="maya" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://theodox.com/">Chimeras & Manticores <strong>technical art, python, the games business, and obscurantism</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/about">About...</a></li>
            <li><a href="/pages/pub">Publications</a></li>
            <li><a href="http://astore.amazon.com/tecsurgui-20">Tech-Art Book Store</a></li>
            <li><a href="/pages/cookbook">Cookbook</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://theodox.com/2014/dog_ate_my_homework" rel="bookmark"
         title="Permalink to The Dog Ate My Homework">The Dog Ate My&nbsp;Homework</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2014-10-30T09:55:00.001000-07:00">
      Thu 30 October 2014
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="http://theodox.com/author/steve-theodore.html">Steve Theodore</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>I had an interesting issue at work the other day. While the details are unit-test specific, I learned a useful general idea that’s worth&nbsp;sharing.  </p>
<p>We run all of our various Maya tools through a single build system which runs unit tests and compiles code for our different targets (currently Maya 2011 and 2015). Ordinarily, since I’m very allergic to using binaries when I don’t have to, this multi-maya setup doesn’t cause us a lot of headaches. I have a little extractor routine which unzips the few binaries we do distribute in the right places, and all the rest of the code is blissfully unaware of which Maya version it’s running (with the exception of the nasty <a href="http://techartsurvival.blogspot.com/2014/09/2015-bug-watch-ls.html">ls bug I mentioned a few weeks ago</a>.)  </p>
<p><a href="http://rs1img.memecdn.com/how-many-times-have-you-heard-amp-quot-my-dog-ate-my-homework-amp-quot_fb_2216011.jpg"><img alt="" src="http://rs1img.memecdn.com/how-many-times-have-you-heard-amp-quot-my-dog-ate-my-homework-amp-quot_fb_2216011.jpg" /></a></p>
<p>Last week, however, we added a new tool and accompanying test suite to the toolkit. It works fine in 2015 (where we do all of our actual development right now), but crashes in 2011. After a bit of head-scratching we eventually realized that this one was absurdly simple: the test uses a saved Maya so that it can work with known, valid data. Of course the file was saved from Maya 2015, so when the Maya 2011 version of the tests tries to run boot up, it falls over because 2011 won’t read a 2015 file.<br />
Or, as the checkin comment has it,&nbsp;“Doh!”  </p>
<h2>Test&nbsp;cancelled!</h2>
<p>The obvious fix is just to skip the test in Maya 2011 - a test that can never pass is hardly generating much useful information, and the likelihood that our small pool of 2011 customers actually need this tool is low anyway. Skipping a test is easy enough if you’re running the tests manually in an <span class="caps">IDE</span> – but a lot more complex if you’re got a build server that’s trying to auto-detect the tests. Plus, designing a system that makes it <em>too</em> easy to skip tests is a Bad Thingtm; - you generally want all of your tests running all the time, since “I’ll re-enable that test after I deal with this problem” is right up there with “the check is in the mail” and “it’s not you, it’s me” in the probity department. <br />
So, the goal is to allow us to conditionally disable tests based on a hard constraint - in this case, when they are running on an inappropriate version of Maya - without compromising the tests as a whole . Secondarily it would be nice to do this without any kind of central registry file - we’d really just like the tests to just run, except when they <em>can’t</em>.  </p>
<p><a href="http://i1.wp.com/lotsofhumor.com/wp-content/uploads/2013/04/didnt-study-for-test-test-cancelled.jpg"><img alt="" src="http://i1.wp.com/lotsofhumor.com/wp-content/uploads/2013/04/didnt-study-for-test-test-cancelled.jpg" /></a></p>
<p>Now, typically a test runner will detect tests by looking for classes that derive from <a href="https://docs.python.org/2/library/unittest.html">unittest.TestCase</a>. The easiest way to skip the test, therefore, is simply not to define it at all - if the test runner doesn’t see the class when it imports your test modules, we’ll be fine. <em>Note: this strategy won’t work if you have some kind of hand-rolled test harness that finds tests by string parsing file contents or something like that! However, you probably want to be doing the standard thing anyway… As they say in Python land, <a href="http://legacy.python.org/dev/peps/pep-0020/">“There should be one– and preferably only one –obvious way to do&nbsp;it.”</a></em>  </p>
<p>In C++ or C# you could do this with a “preprocessor directive”, aka a “#define” - a conditional check that runs at compile time to include or exclude certain parts of a&nbsp;file.   </p>
<p>In Python we don’t even need that: you can just inline the check in your file and it will execute when the module is imported. Here’s a simple example which conditionally use Raymond Hettinger’s <a href="https://pypi.python.org/pypi/ordereddict">ordereddict module</a> in Python 2.6 and the equivalent built-in version in Python&nbsp;2.7:  </p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>  
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>  
<span class="k">else</span><span class="p">:</span>  
    <span class="kn">from</span> <span class="nn">ordereddict</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
</pre></div>


<p>_(If you are total #<span class="caps">IFDEF</span> addict there is also the <a href="http://stackoverflow.com/questions/482014/how-would-you-do-the-equivalent-of-preprocessor-directives-in-python">pypredef module</a>. Not my cup of tea, but the author does make some good points about the utility of his approach).&nbsp;_  </p>
<p>The inline approach works fine in small amounts, but it’s aesthetically unappealing - it forces a bunch of module-level definitions away from the left margin, visually demoting them from important names to generic code blocks. More importantly, it’s easy to mess up: a misplaced indentation can radically change the contents of your file, and even though I’m a big fan of indentations over cur lies, I miss my indents with depressing&nbsp;regularity.  </p>
<p>Fortunately, Python has an elegantly succinct way of annotating code for higher-level purposes without messing up the visual cleanliness and logical flow: <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">decorators</a>. Decorators are handy here for two reasons: first off, they express your intent very clearly by telling future readers something unambiguous about the structure of your code. Secondly, they can execute code (even fairly complex code, though frankly it’s a bad idea for what I’m describing here!) without compromising the layout and readability of your module.<br />
The particularly nice thing about decorators in this case is that the way decorators work in any case is a natural match for the problem we&nbsp;have.   </p>
<h2>The substitute&nbsp;teacher</h2>
<p>A decorator is just a function (or a callable class) which takes another function or class as an argument. When Python finds a decorated function or class, it calls the decorator function and passes the target – that is, the decorated bit of code – as an argument Whatever comes out of the decorator function is then swapped in for the original code. <br />
Here’s a simple example, using functions for&nbsp;simplicity:  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decorated</span><span class="p">(</span><span class="n">original_func</span><span class="p">):</span>  
        <span class="k">def</span> <span class="nf">replacement_func</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>  
        <span class="c1"># this function replaces the original  </span>
        <span class="c1"># it only knows what the original does  </span>
        <span class="c1"># because that was passed in when the  </span>
        <span class="c1"># decorator was called....  </span>
        <span class="k">print</span> <span class="s2">&quot;calling original&quot;</span>  
        <span class="n">result</span> <span class="o">=</span> <span class="n">original_func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  
        <span class="k">print</span> <span class="s2">&quot;original says : &quot;</span><span class="p">,</span> <span class="n">result</span>  
        <span class="k">return</span> <span class="n">result</span>  
    <span class="k">return</span> <span class="n">replacement_func</span>   
    <span class="c1"># return our new replacement function  </span>
    <span class="c1"># but bind it to the name of the original</span>

<span class="nd">@decorated</span>  
<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>  
   <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

<span class="n">example</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  
<span class="c1"># calling original  </span>
<span class="c1"># original says : 3  </span>
<span class="k">print</span> <span class="n">example</span><span class="p">:</span>  
<span class="c1"># 3</span>
</pre></div>


<p>The decorator can completely replace the original code if it wants&nbsp;to:  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">override</span><span class="p">(</span><span class="n">original_func</span><span class="p">):</span>  
   <span class="k">def</span> <span class="nf">completely_different</span><span class="p">():</span>  
       <span class="k">return</span> <span class="s2">&quot;and now for something completely different&quot;</span>

<span class="nd">@override</span>  
<span class="k">def</span> <span class="nf">parrot</span><span class="p">():</span>  
    <span class="k">return</span> <span class="s2">&quot;I’d like to make a complaint about a parrot&quot;</span>

<span class="k">print</span> <span class="n">parrot</span><span class="p">()</span>  
<span class="c1"># and now for something completely different</span>
</pre></div>


<p>Or, it could leave it untouched&nbsp;too:  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">untouched</span><span class="p">(</span><span class="n">original_func</span><span class="p">):</span>  
    <span class="k">return</span> <span class="n">original_func</span>

<span class="nd">@untouched</span>  
<span class="k">def</span> <span class="nf">spam</span><span class="p">():</span>  
    <span class="k">return</span> <span class="s2">&quot;spam!&quot;</span>

<span class="k">print</span> <span class="n">spam</span><span class="p">()</span>  
<span class="c1">#spam!</span>
</pre></div>


<p>The essential thing here is that the decorator sort of like one of those elves who swap out children for changelings. Officially nothing has changed - the name you defined in the un-decorated code is right there - but under the hood it may be&nbsp;different.  </p>
<p><a href="http://bartsblackboard.com/files/2009/11/The-Simpsons-05x11-Homer-The-Vigilante.jpg"><img alt="" src="http://bartsblackboard.com/files/2009/11/The-Simpsons-05x11-Homer-The-Vigilante.jpg" /></a></p>
<h2>Mandatory&nbsp;testing</h2>
<p>Once you understand the decorator-as-changeling idea, it becomes pretty easy to see how the decorator can allow code swaps based on some condition. You might, for example, try to patch around a function which returns an empty list in Maya 2014, but <a href="https://www.blogger.com/blogger.g?blogID=3596910715538761404">crashes in Maya 2015</a>(link):  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">safe_2015</span><span class="p">(</span><span class="n">original_func</span><span class="p">):</span>  
        <span class="k">if</span> <span class="s1">&#39;2015&#39;</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">about</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>  
        <span class="c1"># wrap it for safety in 2015  </span>
        <span class="k">def</span> <span class="nf">safe</span>\<span class="n">_ls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  
            <span class="k">try</span><span class="p">:</span>  
                <span class="k">return</span> <span class="n">original_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>  
                <span class="k">return</span> <span class="p">[]()</span>  
        <span class="k">return</span> <span class="n">safe_ls</span>  
    <span class="k">else</span><span class="p">:</span>  
        <span class="c1"># send it back unchanged in non-2015  </span>
        <span class="k">return</span> <span class="n">original_func</span>

<span class="nd">@safe_2015</span>    
<span class="k">def</span> <span class="nf">do_something</span><span class="p">():</span>  
   \<span class="c1">#....</span>
</pre></div>


<blockquote>
<p>Disclaimer: I wouldn’t use this code in practice! It’s a good example of the principle, but not a wise way to patch around the 2015 ls&nbsp;bug.  </p>
</blockquote>
<p>Returning at long last to the problem of suppressing tests: we just need to harness the power of decorators to replace the class definition of our test classes with something else that won’t get run by our test suite. And, luckily, that’s really easy to do since we don’t have to return&nbsp;anything:  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Only2015</span><span class="p">(</span><span class="n">original</span><span class="p">):</span>  
    <span class="k">if</span> <span class="s1">&#39;2015&#39;</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">about</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>  
            <span class="k">return</span> <span class="n">original</span> <span class="c1"># untouched!  </span>
        <span class="k">else</span><span class="p">:</span>  
            <span class="k">return</span> <span class="nb">object</span> <span class="c1"># the decorated class is now just object</span>
</pre></div>


<p>So if your do something like this in your&nbsp;tests:  </p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>  
<span class="kn">import</span> <span class="nn">maya.standalone</span>  
<span class="k">try</span><span class="p">:</span>  
    <span class="n">maya</span><span class="o">.</span><span class="n">standalone</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>  
<span class="k">except</span><span class="p">:</span>  
    <span class="k">pass</span>


<span class="nd">@Only2015</span>  
<span class="k">class</span> <span class="nc">Test2015Only</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>  
    <span class="k">def</span> <span class="nf">test_its_2015</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  
        <span class="k">assert</span> <span class="s1">&#39;2015&#39;</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">about</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TestOtherVersions</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>  
    <span class="k">def</span> <span class="nf">test_any_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  
        <span class="k">assert</span> <span class="s1">&#39;20&#39;</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">about</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>As you’d expect, both of these test will run and pass when run on a Maya 2015 python. However, under any other version of Maya the file really looks like&nbsp;this:  </p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="kn">import</span> <span class="n">TestCase</span>  
    <span class="kn">import</span> <span class="nn">maya.standalone</span>  
    <span class="k">try</span><span class="p">:</span>  
        <span class="n">maya</span><span class="o">.</span><span class="n">standalone</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>  
    <span class="k">except</span><span class="p">:</span>  
        <span class="k">pass</span>

<span class="c1"># in 2014 &lt;, this TestCase class has been replaced by a dumb object() class  </span>
<span class="k">class</span> <span class="nc">Test2015Only</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">TestOtherVersions</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>  
    <span class="k">def</span> <span class="nf">test</span>\<span class="n">_any</span>\<span class="n">_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  
        <span class="k">assert</span> <span class="s1">&#39;20&#39;</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">about</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>Because <code>Test2015Only()</code> is now an <code>object()</code> instead of a <code>TestCase()</code>, the test runner doesn’t even see it and doesn’t try to run&nbsp;it.  </p>
<h2>Makeup&nbsp;work</h2>
<p>This is a lovely example of why Python can be so much fun. The language has the magical ability to extend itself on the fly - in this case, change the meaning of whole blocks of otherwise conventional code - but at the same time it offers simple, conservative mechanisms that keep that process for degenerating into mere anarchy (or, worse, into <em><a href="http://qph.is.quoracdn.net/main-qimg-eb6eb210fd4116ef10fee083428ed482?convert_to_webp=true">JavaScript</a></em>).  </p>
<p>This particular gimmick was a great way to clean up our messy test set. Predictably, about 30 seconds I verified that it worked I was starting to brainstorm all sorts of cool new uses for this&nbsp;tactic.   </p>
<p>A few more minutes of reflection, however, brought me to see that this kind of trick should be reserved for special occasions. The ability to swap the contents of a name based on runtime condition is definitely cool - but it’s hardly a good practice for readability and maintenance down the road. It happens to be a nice fit for this problem because a test is never going to be used by anything other than the test suite. Trying the same thing with, say, a geometry library that gets imported all over the place would be a nightmare to&nbsp;debug.  </p>
<p>Magic is wonderful but, best used <em>sparingly</em>.  </p>
<p><a href="http://pad2.whstatic.com/images/thumb/f/f5/Get-out-of-Class-Step-6.jpg/670px-Get-out-of-Class-Step-6.jpg"><img alt="" src="http://pad2.whstatic.com/images/thumb/f/f5/Get-out-of-Class-Step-6.jpg/670px-Get-out-of-Class-Step-6.jpg" /></a></p>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>