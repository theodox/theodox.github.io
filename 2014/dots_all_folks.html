<!DOCTYPE html>
<html lang="en">
<head>
          <title>Chimeras & Manticores</title>
        <meta charset="utf-8" />
        <link href="http://theodox.com/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Chimeras & Manticores Full Atom Feed" />
        <link href="http://theodox.com/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="Chimeras & Manticores Full RSS Feed" />



    <meta name="tags" content="math" />
    <meta name="tags" content="techart" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://theodox.com/">Chimeras & Manticores <strong>technical art, python, the games business, and obscurantism</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/about">About...</a></li>
            <li><a href="/pages/pub">Publications</a></li>
            <li><a href="http://astore.amazon.com/tecsurgui-20">Tech-Art Book Store</a></li>
            <li><a href="/pages/cookbook">Cookbook</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://theodox.com/2014/dots_all_folks" rel="bookmark"
         title="Permalink to Dot’s all, folks">Dot&#8217;s all,&nbsp;folks</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2014-11-29T00:12:00.001000-08:00">
      Sat 29 November 2014
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="http://theodox.com/author/steve-theodore.html">Steve Theodore</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>Last time out I went on (probably a bit too long) on the virtues of the dot product - the operation which takes two lists of numbers and multiplies them to create a single product. The highlight of the whole thing was the <em>cosine dot product</em> - the handy fact that the dot product of two normalized vectors is the cosine of the angle between&nbsp;them.  </p>
<p>Now that the theory is out of the way, it’s time to highlight some of the zillions of applications for this handy little&nbsp;operation.  </p>
<blockquote>
<p>If none of this sounds familiar you might want to <a href="bagels_and_coffee.html">revisit the first post in the series</a> before&nbsp;continuing.   </p>
</blockquote>
<p>The dot product is incredibly useful for a <span class="caps">TA</span> for two reasons. First, dots allow you to <em>convert between geometric measures and angles</em> without the need for matrices or complex formulae. Second, dots provide an efficient way to <em>project one vector on to another</em>, allowing you to measure distances and quantities relative to an arbitrary axis or vector - a great tool for anything from color conversions in a pixel shader to measuring motion in a complex rig.<br />
Before getting down to cases, a quick reminder of one important side fact we pointed out last time. A cosine dot product can only tell you <em>how different</em> the angle between two vectors is - <strong>not</strong> what rotations would transform one vector into the other. If you try out this example you’ll see that the dot of <code>[1,0,0]</code> against both <code>[.5, .866, 0]</code> and <code>[.5, -.866, 0]</code> is .5, which (if you remember your sines and cosines) means the relative angle is 30 degrees. However one of those two vectors is clockwise from <code>[1,0,0]</code> and the other is counter-clockwise from it. The dot, by itself, can’t tell you which one is which. <em>Don’t forget that&nbsp;bit!</em></p>
<blockquote>
<p>As I mentioned in the last article, the math for dots is trivially simple. Maxscript <a href="http://www.scriptspot.com/bobo/mel2mxs/arithmetic.htm">includes vector math functions</a> by default, as does <span class="caps">MEL</span>, but vanilla maya.cmds does not. If you want to experiment with examples mentioned here in Maya python, you can import <code>pymel.core.datataypes</code> and use the <code>Vector</code>. I’ve also put a <a href="https://github.com/theodox/vector">simple vector module up on Github</a> that works in <code>Maya.cmds</code>. I’ll be using that for these examples but translating between <span class="caps">MXS</span>, Pymel, and cmds should be a&nbsp;no-brainer.</p>
</blockquote>
<h2>Rigging</h2>
<p>One of the most common tasks in rigging is wrangling information into the correct frame of reference.This is particularly tough when dealing with angular data, since angles are often presented in the form of Euler angles whose numeric values can vary unpredictably and which are therefore hard to use in expressions or code. Here are a few examples of how dot’s can help riggers get angular information while avoiding the Euler&nbsp;blues  </p>
<h4>The&nbsp;Bends</h4>
<p>Dot’s are an excellent way to measure the extension of a limb, without relying on an Euler value which might be affected by local axis orientations, joint orients, or rotated local axes. Here’s an example that gets a reliable value for the extension of an arm (note: this is vanilla maya, you could do it more succintly with Pymel but it’s a better illustration to do it from&nbsp;scratch)  </p>
<div class="highlight"><pre><span></span><span class="n">shoulder_pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="s1">&#39;r_shoulder&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
<span class="n">elbow_pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="s1">&#39;r_elbow&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
<span class="n">wrist_pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="s1">&#39;r_wrist&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">bicep_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">elbow_pos</span><span class="p">)</span> <span class="o">-</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">shoulder_pos</span><span class="p">))</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>  
<span class="n">forearm_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">wrist_pos</span><span class="p">)</span> <span class="o">-</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">elbow_pos</span><span class="p">))</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>  
<span class="n">elbow_bend</span> <span class="o">=</span> <span class="n">Vector3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bicep_vector</span><span class="p">,</span> <span class="n">forearm_vector</span><span class="p">)</span>
</pre></div>


<p>then <code>arm_extension</code> will be 1 at full extension and 0 when the arm is bent back completely on itself (<em>ouch!</em>). You can map use this extension value to drive muscle deformations, blendshapes, or other behaviors without worrying about th underlying Euler values or converting from angles to linear&nbsp;ranges.  </p>
<h4>Leaning&nbsp;In</h4>
<p>It’s often useful to have a general idea what a character’s whole body is doing, rather than focusing entirely on individual joint positions and orientations. For example, you might want to have rig behaviors turn on when a character is ‘upright’ and off when it it is ‘prone’, or vice-versa. Figuring out the gross orientation is often hard because there are so many bones cooperating to produce the visual effect – and because different animators may use different controls in different ways: animator A may prefer to put all of the big rotations onto a center-of-gravity control while animator B does everything on the&nbsp;pelvis.  </p>
<p>Dots are great for extracting pose info from the world space position of key bones instead of trying to intuit them from rotation values. For&nbsp;example:  </p>
<div class="highlight"><pre><span></span><span class="n">head_pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="s1">&#39;head&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
<span class="n">pelvis_pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="s1">&#39;pelvis&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># how upright is the character’s body?  </span>
<span class="n">body_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">head_pos</span><span class="p">)</span> <span class="o">-</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">pelvis_pos</span><span class="p">))</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>  
<span class="n">upright</span> <span class="o">=</span> <span class="n">Vector3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">body_vector</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># for a y-up world</span>
</pre></div>


<p>Here upright will be close to 1 for an upstanding character, close to 0 for a prone character, and close to -1 for an upside down character (eg, during a handstand). This version tracks the pelvis-to-head vector so it will respond to things like a hunched-over spine; but one of the nice side effects of vector math it that you can easily ‘weight’ different elements as you put together your vectors. For&nbsp;example:  </p>
<div class="highlight"><pre><span></span><span class="n">chest_pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="s1">&#39;spine_3&#39;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
<span class="n">head_and_chest</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">chest_pos</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">head_pos</span><span class="p">))</span>  <span class="o">/</span> <span class="mf">3.0</span>  
<span class="n">body_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">head_and_chest</span><span class="p">)</span> <span class="o">-</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">pelvis_pos</span><span class="p">))</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>  
<span class="n">upright</span> <span class="o">=</span> <span class="n">Vector3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">body_vector</span><span class="p">,</span> <span class="n">Vector3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>


<p>would include bias the uprightness vector towards ‘spine_3’, diminishing the influence of the head on the final&nbsp;results.  </p>
<h4>Looky&nbsp;here</h4>
<p>You don’t always have to use positions to drive dot-product calculations. You can always get the local orientation of a transform by looking at it’s matrix (the exact reason for this will be shown in a later posting, for now take it on faith). This allows you to see how closely a given object is oriented towards a given&nbsp;vector.   </p>
<p>For example, something like this will help you figure out if a character’s body is oriented in roughly the same direction as the character’s root&nbsp;bone:  </p>
<div class="highlight"><pre><span></span><span class="c1"># assuming that the bones are constructed with positive z as &#39;forward&#39;  </span>
<span class="n">world_forward</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">cmds</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="s2">&quot;.worldMatrix&quot;</span><span class="p">)[</span><span class="mi">8</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span>  
<span class="n">root_forward</span> <span class="o">=</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">world_forward</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">))</span>  
<span class="n">pelvis_forward</span> <span class="o">=</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">world_forward</span><span class="p">(</span><span class="s1">&#39;pelvis&#39;</span><span class="p">))</span>  
<span class="n">shoulders_forward</span> <span class="o">=</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">world_forward</span><span class="p">(</span><span class="s1">&#39;spine_3&#39;</span><span class="p">))</span>  
<span class="n">head_forward</span> <span class="o">=</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">world_forward</span><span class="p">(</span><span class="s1">&#39;head&#39;</span><span class="p">))</span>  
<span class="c1"># get a weighted average of the pelvis, shoulder and head directions  </span>
<span class="n">composite</span> <span class="o">=</span> <span class="p">((</span><span class="n">pelvis_forward</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">shoulders_forward</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">head_forward</span><span class="p">)</span> <span class="o">/</span> <span class="mf">5.0</span>  
<span class="c1"># flatten the composite and root vectors into 2 dimensions:  </span>
<span class="n">composite</span> <span class="o">=</span> <span class="n">composite</span> <span class="o">*</span> <span class="n">Vector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  
<span class="n">root_forward</span> <span class="o">=</span> <span class="n">root_forward</span> <span class="o">*</span> <span class="n">Vector3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  
<span class="n">orientation</span> <span class="o">=</span> <span class="n">Vector3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">composite</span><span class="o">.</span><span class="n">normalized</span><span class="p">(),</span> <span class="p">(</span><span class="n">root_forward</span><span class="o">.</span><span class="n">normalized</span><span class="p">())</span>
</pre></div>


<p>A value of 1 would have the character facing precisely along the same direction as it’s root bone in 2D. This kind of thing is especially useful when you’re trying to manage a lot of animations which need to begin and end in similar poses - you can quickly check the overall posture of a lot of characters without too much detailed analysis to spot problems before going in and looking at the troublesome ones for hand&nbsp;fixing.  </p>
<h2>shaders</h2>
<p>Even more than rigging, shader authoring frequently involves a return to the math fundamentals. The most familiar example of the dot product in shader writing is the <a href="https://www.blogger.com/blogger.g?blogID=3596910715538761404">Lambert rendering equation</a> which we discussed in the last post. However, you can get a variety of other handy effects from the dot inb shaders. The key is to find the right set of vectors to work with. <br />
For example, if you dot a surface normal against the vector along which the camera is looking, the result will tell you how directly surface is facing the camera. This allows you to create a <a href="http://kylehalladay.com/blog/tutorial/2014/02/18/Fresnel-Shaders-From-The-Ground-Up.html">fresnel</a> or edge-highlighting&nbsp;effect.   </p>
<p>Here’s a snippet of a very minimal Unity shader that illustrates the&nbsp;principle:</p>
<div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutput</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>  
        <span class="o">//</span> <span class="n">a</span> <span class="n">hacky</span> <span class="n">way</span> <span class="n">to</span> <span class="n">get</span> <span class="n">the</span> <span class="n">camera</span> <span class="n">vector</span><span class="err">…</span>  
        <span class="n">float3</span> <span class="n">cam_vect</span> <span class="o">=</span> <span class="n">UNITY_MATRIX_IT_MV</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">xyz</span><span class="p">;</span>  
        <span class="nb">float</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span> <span class="n">cam_vect</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">Normal</span><span class="p">);</span>  
        <span class="n">o</span><span class="o">.</span><span class="n">Albedo</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="nb">pow</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">FresnelPower</span><span class="p">)</span> <span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">);</span>  
        <span class="n">o</span><span class="o">.</span><span class="n">Alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
        <span class="p">}</span>
</pre></div>


<p>The only thing worth noting here is the way the result value is being inverted: we want the result number to be close to 1 at the horizon and close to zero where the camera normal and the surface normal are aligned, which is the reverse of what the dot would normally give us. By raising the result value to a higher or lower power (using <code>pow</code>) we can sharpen or soften the effect; since it the result value should always be 1 or lower a higher power will result in a smaller result value and thus a tighter highlight as you can see in the&nbsp;images.  </p>
<p><a href="http://4.bp.blogspot.com/-CPrevKORkfE/VHl_alL2OkI/AAAAAAABLWg/N9jWYdWum-4/s1600/fresnel.jpg"><img alt="" src="http://4.bp.blogspot.com/-CPrevKORkfE/VHl_alL2OkI/AAAAAAABLWg/N9jWYdWum-4/s1600/fresnel.jpg" /></a>    </p>
<blockquote>
<p>The dotting the camera vector against the surface normal produces an edge highlight fresnel-style&nbsp;effect.   </p>
</blockquote>
<p>The size of the effect can be tweaked by raising the dot product value to a higher or lower&nbsp;power.  </p>
<p>You can re-map that dot product in other ways as well. The popular Team Fortress 2 shader, for example, takes the dot between the light and the surface normal - which, of course, will range in value from -1 to 1 - and re-maps it onto the range 0 to 1 so it can be used to lookup a color value from a texture. That’s how the game achieves it’s distinctive ‘wrap-around’&nbsp;lighting:  </p>
<p><img alt="" src="http://www.maginot.eu/space/mgto/projects/mods/tf2_lightwarp/mgto_lightwarp_mod.jpg" /> </p>
<blockquote>
<p>The Team Fortress shader uses a shifted dot-product to look up lighting values from a hand-authored color ramp, creatng a distinctive illustrational&nbsp;look. </p>
</blockquote>
<p>Both of those uses use the ‘cosine falloff’ intepretation of the dot product, that is, they represent angular differences. However dots have another mathematical meaning: they represent the projection of one vector onto another. One really cool aspect the projective use of the dot is that the logic works in color spaces as well as physical space. For example, a shader writer of can get the luminance of a pixel elegantly like&nbsp;this:  </p>
<div class="highlight"><pre><span></span><span class="nb">float</span> <span class="n">luma</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span> <span class="n">float3</span><span class="p">(</span><span class="mf">0.2126</span><span class="p">,</span> <span class="mf">0.7152</span><span class="p">,</span> <span class="mf">0.0722</span><span class="p">),</span> <span class="n">pixel_color</span><span class="p">);</span>
</pre></div>


<p>Which is essentially projecting the color onto a ‘luminance vector’ dominated by green (numbers derived from <a href="https://en.wikipedia.org/wiki/Relative_luminance">this</a>) You could use the same trick to identify ‘warm’ colors by dotting against a warm rgb value like (.707, .707, 0) - high dot values will be warm and low dot values will be cool. It takes some meditation to really grok what’s going on (try parsing what’s happening in <a href="http://makc3d.wordpress.com/2011/04/06/matching-colors-in-rgb/">this example</a>!) but dots can be a very handy trick for navigating color space as well as 3-d space.<br />
Shader writers have one more sneaky use for dots - they can be a cheap substitute for selection functions. Shader authors often have to pack data into vectors for efficiency, but accessing one component of a vector would need an expensive if-then branch in theshader. Dots, however, can let you pick one component out of your vector without using branches. Since the dot of any vector composed of all zeros is of course zero. If one component is a one and the rest are zeros, the result will be the corresponding component of the other vector.&nbsp;Thus:  </p>
<div class="highlight"><pre><span></span><span class="n">float3</span> <span class="n">y</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>  
<span class="n">float3</span> <span class="n">x</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>  
<span class="n">float3</span> <span class="n">val</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.866</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
<span class="c1">// dot(x,val) == val.x = .5;  </span>
<span class="c1">// dot(y,val) == val.y = .866;</span>
</pre></div>


<p>This is more compiler friendly than inserting a branch into the shader code to conditionally pick one component or another. I’ve found it especially useful in Unity, where ShaderLab limits your ability to pass custom data types to shaders and it’s often necessary to pack data into vectors or matrices just to get it from the game to the&nbsp;shader.  </p>
<h2>tools</h2>
<p>It’s easy to see who the kinds of tricks we’ve already laid out for shaders and rigging generalize for tool writing. The dot of a surface normal and a vector is a great proxy for whether or not the a surface is facing something, dots are great for analyzing geometry. For example, A tree-and-rock scattering script can dot the normal of a terrain against gravity to figure out which slopes are too steep for trees, or which areas are bottomland where there ought to be lots of bushes. A terrain editing tool could against a sun vector to identify exposed areas where the grass is yellowed and shady spots where it’s lush and&nbsp;green.   </p>
<p>As with rigging , the dot also provides a way to check relative orientations. For example, you might need to know if an object has been where another object can ‘see’ it. If you dot a reference vector - such the object’s local X or Z axs - against the vector to a target, you can figure out if the target is ‘ahead’ or ‘behind’ the reference object. For example this function would tell you if the target was within some angle of the forward axis of the&nbsp;observer:  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">target_visible</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cone</span><span class="o">-</span><span class="n">angle</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="n">_</span><span class="p">):</span>  
    <span class="sd">&quot;&quot;&quot;Is target within &lt;coneangle&gt; when viewed on references&#39; local Z axis?&quot;&quot;&quot;</span>  
    <span class="n">reference</span><span class="o">-</span><span class="n">vector</span> <span class="o">=</span>  <span class="n">cmds</span><span class="o">.</span><span class="n">getAttr</span><span class="p">(</span><span class="n">reference</span> <span class="o">+</span> <span class="s2">&quot;.worldMatrix&quot;</span><span class="p">)[</span><span class="mi">8</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span>  
    <span class="n">target_pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ws</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
    <span class="n">reference</span><span class="o">-</span><span class="n">pos</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">xform</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ws</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
    <span class="n">target</span><span class="o">-</span><span class="n">vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">(</span><span class="o">*</span><span class="n">target</span><span class="o">-</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="n">Vector3</span><span class="p">(</span><span class="o">*</span> <span class="n">reference</span><span class="o">-</span><span class="n">pos</span><span class="p">))</span>  
    <span class="k">return</span> <span class="n">Vector3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">target</span><span class="o">-</span><span class="n">vector</span><span class="o">.</span><span class="n">normalized</span><span class="p">(),</span> <span class="n">reference</span><span class="o">-</span><span class="n">vector</span><span class="o">.</span><span class="n">normalized</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="n">cone</span><span class="o">-</span><span class="n">angle</span>
</pre></div>


<p>You could restrict that to one or two axes using the same trick in the rigging example, or use the full cone angle as done&nbsp;here.  </p>
<blockquote>
<p>As an aside, this brings up the issue of converting between dots and angles. Since the geometric dot product (as always, assuming you’ve got normalized vectors) is a cosine, you can convert it to an angle by using the arc-cosine function (<code>acos</code> in Python and most other languages) like&nbsp;so:</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="n">cosine</span> <span class="o">=</span> <span class="n">Vector3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>  
<span class="n">angle_in_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">cosine</span><span class="p">)</span>  
<span class="n">angle_in_degrees</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle_in_radians</span><span class="p">)</span>
</pre></div>


<p>The projective function of dots is also useful in tools. For example, you can use a dot to clamp a line to the position of the mouse, even if the line is constrained so that the mouse doesn’t physically rest on the&nbsp;line:  </p>
<div class="highlight"><pre><span></span><span class="n">line_vector</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="mf">.707</span><span class="p">,</span> <span class="mf">.707</span><span class="p">)</span>  <span class="err">#</span> <span class="n">a</span> <span class="mi">45</span> <span class="n">degree</span> <span class="n">line</span>  
<span class="n">line_origin</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>    <span class="err">#</span> <span class="n">start</span> <span class="n">drawing</span> <span class="n">at</span> <span class="n">pixel</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">)</span>  
<span class="k">while</span> <span class="p">(</span><span class="n">mouse</span><span class="p">.</span><span class="n">down</span><span class="p">())</span><span class="o">:</span>  
    <span class="n">line_end</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">Vector2</span><span class="p">(</span><span class="o">*</span><span class="n">mouse</span><span class="p">.</span><span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">line_origin</span><span class="p">,</span> <span class="n">line_vector</span><span class="p">)</span>  
    <span class="n">draw_line</span> <span class="p">(</span><span class="n">line_origin</span><span class="p">,</span> <span class="n">line_origin</span> <span class="o">+</span> <span class="n">line_end</span><span class="p">)</span>
</pre></div>


<h2>Further&nbsp;reading</h2>
<p>If this one whetted your appetite and you need to know more, here’s a few links I found handy while reading&nbsp;up:  </p>
<ul>
<li><a href="http://www.chrisevans3d.com/pub/_blog/maya-python-vector-math-primer/">Chris Evans’ vector math&nbsp;tutorial</a></li>
<li>A <a href="http://mathinsight.org/dot_product">page on projective dot products</a>, along with an applet that helps you visualize how the projection&nbsp;works</li>
<li><a href="http://blog.wolfire.com/2009/07/linear-algebra-for-game-developers-part-2/">This post from Wolfire</a>, developers of <a href="http://www.wolfire.com/overgrowth">Overgrowth</a> includes some nice examples of how dots are used in <span class="caps">AI</span> and game code (plus a peek at some other concepts I’ll be covering later in this&nbsp;series)</li>
<li><strong>Update</strong>: <a href="https://plus.google.com/105359351421932966635">+Paul Vosper</a>  put me on to the excellent <a href="http://scratchapixel.com/">Scratchapixel.com</a></li>
</ul>
<p>I&#8217;ll be back on the math trail again as soon as I emerge from my <a href="http://www.webmd.com/food-recipes/features/the-truth-about-tryptophan">mythical tryptophan&nbsp;coma.</a>  </p>
<h2>Posts in this&nbsp;series</h2>
<ul>
<li><a href="bagels_and_coffee.html">Bagels and Coffee (intro to dot&nbsp;products)</a></li>
<li><a href="dots_all_folks.html">Dots All Folks (dot product&nbsp;uses)</a></li>
<li><a href="dot_matrix.html">Dot Matrix (intro to&nbsp;matrices)</a></li>
<li><a href="adventures-in-4th-dimension.html">Adventures in the 4th Dimension (translation&nbsp;matrices)</a></li>
<li><a href="to-scale.html">To Scale! (scale&nbsp;matrices)</a></li>
</ul>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>