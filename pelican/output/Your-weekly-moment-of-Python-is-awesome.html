<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/stylesheet/font-awesome.min.css">


    <link href="http://blog.theodox.com/atom/%s_all.atom.xml" type="application/atom+xml" rel="alternate" title="theodox.com Atom">



  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Steve Theodore" />
<meta name="description" content="pending" />
<meta name="keywords" content="">
<meta property="og:site_name" content="theodox.com"/>
<meta property="og:title" content="Your weekly moment of Python-is-awesome"/>
<meta property="og:description" content="pending"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./Your-weekly-moment-of-Python-is-awesome.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2014-05-27 22:58:00.001000-07:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/steve-theodore.html">
<meta property="article:section" content="blog"/>
<meta property="og:image" content="">
  <title>theodox.com &ndash; Your weekly moment of Python-is-awesome</title>
</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="./theme/img/profile.png" alt="" title="">
      </a>
      <h1><a href="."></a></h1>
      <p></p>
      <nav>
        <ul class="list">
          <li><a href="index.html" target="_blank">home</a></li>
          <li><a href="http://python.org/" target="_blank">Python.org</a></li>
          <li><a href="http://jinja.pocoo.org/" target="_blank">Jinja2</a></li>
          <li><a href="#" target="_blank">You can modify those links in your config file</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-linkedin" href="https://www.linkedin.com/in/stevetheodore" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-github" href="https://github.com/theodox" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/u/0/+SteveTheodore480BC/posts" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/1936075/theodox" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id="Your-weekly-moment-of-Python-is-awesome">Your weekly moment of Python-is-awesome</h1>
    <p>Posted on Tue 27 May 2014 in <a href="./category/blog.html">blog</a></p>
  </header>
  <div>
    <p>I stumbled across a cool little idea while working on a refactor of my python tools build system, and although it is not really ready for prime-time it's fun enough I had to share.  With a little bit of work you can <em>load Python modules directly over the web via http!</em>  How cool is that?  </p>
<p>Details  &amp; code after the jump  </p>
<p>In the past I've always gave users a userSetup.py which automatically downloads a zip file containing all the rest of my code from a net share. While this works quite well, the userSetup file itself is a bit of a weak link. Although it changed pretty rarely, it was a bit more complex than I liked. In an ideal world, the user setup would be just a couple of lines, highly resistant to breakage and easy to leave untouched for months or years.  All the changeable stuff should happen off in the ether, so users always get the latest hotness.  </p>
<p>While pondering how to improve this, I was trolling Doug Hellman's invaluable <a href="http://pymotw.com/2/">Python Module of the Week</a> site and stumbled onto his discussion of <a href="http://pymotw.com/2/sys/imports.html">custom Python module finders</a>. Basically, a module finder is a class which you can register with python to tell it how to look for modules. The key word there is 'how', not where' -- a module finder can do anything it wants to find or create a module, as long as it has returns an object with a load_module method that python can use to actually pop the code into sys.modules. It's particularly cool because the process is <em>completely transparent</em> to the calling code: if you call  </p>
<p><code>import XXX</code>  </p>
<p>you'll get XXX, even if your custom finder/loader had to generate it by consulting the _I Ching _and waiting for the right phase of the moon.  </p>
<p>That sounds like fun (jeez, my sense of fun has gotten pretty esoteric). So, I hacked up a highly experimental example of a module loader that will look on the web for a python module being served up via http and import it as if it were local.  </p>
<p>Here's the first bit, the module finder which is in charge of looking for the code when somebody says 'import xxx':  </p>
<div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;  </span>
<span class="sd">web_shim.py</span>

<span class="sd">Exposes a custom module loader and importer which allow for download, cache and  </span>
<span class="sd">load of python modules stored on an HTTP server</span>

<span class="sd">To activate, add the class to sys.path_hooks:</span>

<span class="sd">    sys.path_hooks.append(WebFinder)  </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">imp</span>  
<span class="kn">import</span> <span class="nn">sys</span>  
<span class="kn">import</span> <span class="nn">urllib2</span>  
<span class="kn">import</span> <span class="nn">binascii</span>  
<span class="kn">import</span> <span class="nn">os</span>  
<span class="kn">import</span> <span class="nn">tempfile</span>


<span class="k">class</span> <span class="nc">WebFinder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  
    <span class="sd">&#39;&#39;&#39;  </span>
<span class="sd">    A custom module finder (background: http://pymotw.com/2/sys/imports.html)  </span>
<span class="sd">    that will find and load modules via http connections, as long as the  </span>
<span class="sd">    module file&#39;s parent http path is on the system path</span>

<span class="sd">    The module file is downloaded to the users temp directory. When it changes, it  </span>
<span class="sd">    will be replaced with the latest version from the server. Returns a WebLoader  </span>
<span class="sd">    for the cached file.  </span>
<span class="sd">    &#39;&#39;&#39;</span>  
    <span class="n">CACHE_DIR</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_entry</span><span class="p">):</span>  
        <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;http&quot;</span> <span class="ow">in</span> <span class="n">path_entry</span><span class="p">:</span>  
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">()</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">path_entry</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CACHE_DIR</span><span class="p">)</span>  
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">find_module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fullname</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>  
        <span class="n">expanded</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="n">fullname</span> <span class="o">+</span> <span class="s2">&quot;.py&quot;</span><span class="p">))</span>  
        <span class="k">try</span><span class="p">:</span>  
            <span class="n">target_url</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">fullname</span> <span class="o">+</span> <span class="s2">&quot;.py&quot;</span><span class="p">)</span>  
            <span class="bp">self</span><span class="o">.</span><span class="n">target_url</span> <span class="o">=</span> <span class="n">target_url</span>  
            <span class="n">dl</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">target_url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>  
            <span class="n">crc</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>  
            <span class="n">old</span> <span class="o">=</span> <span class="mh">0xffffffff</span>  
            <span class="k">try</span><span class="p">:</span>  
                <span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">expanded</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span>  
                <span class="n">disk_date</span> <span class="o">=</span> <span class="n">handle</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>  
                <span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  
                <span class="n">old</span> <span class="o">=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">disk_date</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span>  
            <span class="k">except</span><span class="p">:</span>  
                <span class="n">old</span> <span class="o">=</span> <span class="mh">0xffffffff</span>  
            <span class="k">if</span> <span class="n">crc</span> <span class="o">!=</span> <span class="n">old</span><span class="p">:</span>  
                <span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">expanded</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span>  
                <span class="n">handle</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>  
                <span class="n">handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  
            <span class="k">return</span> <span class="n">WebLoader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_url</span><span class="p">,</span> <span class="n">expanded</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>  
        <span class="k">except</span><span class="p">:</span>  
            <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">expanded</span><span class="p">)):</span>  
                <span class="k">return</span> <span class="n">WebLoader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_url</span><span class="p">,</span> <span class="n">expanded</span><span class="p">,</span> <span class="n">fullname</span><span class="p">)</span>
</pre></div>


<p>The module finder's job is to be pointed at a path (in this case, 'self.url') If the path is not something this finder knows how to handle, it raises an ImportError. Otherwise, it sticks around until Python calls find_module with a module name, at which point it will return a module loader object (see below) or None if it doesn't know what to do.  </p>
<p>In this case, we do everything as simply as possible. The finder only works on a path with 'http' in it (note that's not really the right way to check for a url! It's enough for proof of concept, though). The finder just fills out the path with the name of the module (plus ".py") and tries to download it into the user's temp directory. The business with the hex numbers is just a crc check to make sure that the downloaded module is the latest version. If this is the first time you've grabbed the file -- or if the code on the server has changed  -- the cached copy will be refreshed.  </p>
<p>The second half of the operation is the WebLoader, which loads the cached module:  </p>
<div class="highlight"><pre><span></span><span class="c1"># usess the same imports as WebFinder.py</span>

<span class="s s-Atom">class</span> <span class="nv">WebLoader</span><span class="p">(</span><span class="s s-Atom">object</span><span class="p">)</span><span class="s s-Atom">:</span>  
    <span class="s s-Atom">&#39;&#39;&#39;  </span>
<span class="s s-Atom">    Import loader (see http://pymotw.com/2/sys/imports.html for background)  </span>
<span class="s s-Atom">    which loads modules cached by a WebFinder using imp.load_source  </span>
<span class="s s-Atom">    &#39;&#39;&#39;</span>  
    <span class="s s-Atom">def</span> <span class="k">__</span><span class="nf">init__</span><span class="p">(</span><span class="s s-Atom">self</span><span class="p">,</span> <span class="s s-Atom">url</span><span class="p">,</span> <span class="s s-Atom">filepath</span><span class="p">,</span> <span class="s s-Atom">name</span><span class="p">)</span><span class="s s-Atom">:</span>  
        <span class="s s-Atom">self</span><span class="p">.</span><span class="s s-Atom">url</span> <span class="o">=</span> <span class="s s-Atom">url</span>  
        <span class="s s-Atom">self</span><span class="p">.</span><span class="s s-Atom">name</span> <span class="o">=</span> <span class="s s-Atom">name</span>  
        <span class="s s-Atom">self</span><span class="p">.</span><span class="s s-Atom">file</span> <span class="o">=</span> <span class="s s-Atom">filepath</span>  
        <span class="s s-Atom">return</span>

    <span class="s s-Atom">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="s s-Atom">self</span><span class="p">,</span> <span class="s s-Atom">fullname</span><span class="p">)</span><span class="s s-Atom">:</span>  
        <span class="s s-Atom">if</span> <span class="s s-Atom">fullname</span> <span class="s s-Atom">in</span> <span class="s s-Atom">sys</span><span class="p">.</span><span class="nn">modules</span><span class="p">:</span>  
            <span class="o">mod</span> <span class="o">=</span> <span class="s s-Atom">sys</span><span class="p">.</span><span class="s s-Atom">modules</span><span class="p">[</span><span class="s s-Atom">fullname</span><span class="p">]</span>  
            <span class="s s-Atom">return</span> <span class="o">mod</span>  
            <span class="s s-Atom">#</span> <span class="s s-Atom">bail</span> <span class="s s-Atom">now</span> <span class="s s-Atom">so</span> <span class="s s-Atom">we</span> <span class="s s-Atom">don&#39;t mislead users  </span>
<span class="s s-Atom">            # if mod was found somewhere else!  </span>
<span class="s s-Atom">        else:  </span>
<span class="s s-Atom">            mod = sys.modules.setdefault(fullname, imp.load_source(fullname, self.file))  </span>
<span class="s s-Atom">            mod.__file__ = self.file  </span>
<span class="s s-Atom">            mod.__name__ = fullname  </span>
<span class="s s-Atom">            mod.__path__ = [self.url]  </span>
<span class="s s-Atom">            mod.__loader__ = self  </span>
<span class="s s-Atom">            mod.__package__ = &#39;</span><span class="p">.</span><span class="s s-Atom">&#39;.join(fullname.split(&#39;</span><span class="p">.</span><span class="err">&#39;</span><span class="p">)[:-</span><span class="mi">1</span><span class="p">])</span>  
            <span class="s s-Atom">return</span> <span class="o">mod</span>
</pre></div>


<p>A moduleloader can do all sorts of fancy things (the test code on PyMOTW, for example, loads a module from a python shelf database) but in this case I'm doing the simplest thing possible, which is to use imp.load_source on our cached python file. imp, if you're not familiar with it, is a super useful built-in module which provides access to most of the internals of python's import process). Actually using the code is the cool part. All you need to do is to register the finder with sys.path_hooks and then add the web server with your modules on in to your path:   </p>
<div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WebFinder</span><span class="p">)</span>  
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;http://www.inference.phy.cam.ac.uk/mackay/python/compression/huffman&quot;</span><span class="p">)</span>

<span class="c1"># with the url on the path, just use import  </span>
<span class="kn">import</span> <span class="nn">Example</span>  
<span class="k">print</span> <span class="n">Example</span><span class="o">.</span><span class="n">__path__</span>  
<span class="c1">#[&#39;http://www.inference.phy.cam.ac.uk/mackay/python/compression/huffman/Example.py&#39;]</span>

<span class="c1"># the module&#39;s __path__ will point at the url, but __file__ points at the cached  </span>
<span class="c1"># file on disk</span>
</pre></div>


<p>This isn't really something I'd be comfortable using in production without more work.  There's no security and no authentication, so not only is your code up on the web for anybody to see, you're also executing code off the web with no idea what it will do. It would be OK for an intranet if you were pretty sure none of your coworkers fancies him/herself a master prankster, but I'd slather on the security before trying this over long distances!  </p>
<p>Another obvious improvement would be to figure out a how to diff the local version of the file against the version on the http server without actually downloading the whole thing; that would be simple if the server could be asked for the CRC directly, but it would mean a tighter coupling between the finder and the server (which might be a good thing, security wise).  Another improvement might be to hack the loader so it force reloaded the module if the server version had changed, although that could have unintended side effects if the -- <br />
 The point, however -- assuming there is one --  is how freaking awesome python's infrastructure is. Live loading of code over the net, transparent to all your other code, in about 50 lines?  Hat's off to Guido.   </p>
<p><a href="http://www.wired.com/wp-content/uploads/blogs/wiredenterprise/wp-content/uploads/2012/06/beard-programmers-final-two.png"><img alt="" src="http://www.wired.com/wp-content/uploads/blogs/wiredenterprise/wp-content/uploads/2012/06/beard-programmers-final-two.png" /></a></p>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>
</article>

    <footer>
        <p>&copy; Steve Theodore </p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Your weekly moment of Python-is-awesome",
  "headline": "Your weekly moment of Python-is-awesome",
  "datePublished": "2014-05-27 22:58:00.001000-07:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Steve Theodore",
    "url": "./author/steve-theodore.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "./Your-weekly-moment-of-Python-is-awesome.html",
  "description": "pending"
}
</script></body>
</html>