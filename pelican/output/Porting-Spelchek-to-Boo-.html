<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/stylesheet/font-awesome.min.css">


    <link href="http://blog.theodox.com/atom/%s_all.atom.xml" type="application/atom+xml" rel="alternate" title="theodox.com Atom">



  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Steve Theodore" />
<meta name="description" content="pending" />
<meta name="keywords" content="">
<meta property="og:site_name" content="theodox.com"/>
<meta property="og:title" content="Porting Spelchek to Boo"/>
<meta property="og:description" content="pending"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./Porting-Spelchek-to-Boo-.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2015-06-06 22:13:00-07:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/steve-theodore.html">
<meta property="article:section" content="blog"/>
<meta property="og:image" content="">
  <title>theodox.com &ndash; Porting Spelchek to Boo</title>
</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="./theme/img/profile.png" alt="" title="">
      </a>
      <h1><a href="."></a></h1>
      <p></p>
      <nav>
        <ul class="list">
          <li><a href="index.html" target="_blank">home</a></li>
          <li><a href="http://python.org/" target="_blank">Python.org</a></li>
          <li><a href="http://jinja.pocoo.org/" target="_blank">Jinja2</a></li>
          <li><a href="#" target="_blank">You can modify those links in your config file</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-linkedin" href="https://www.linkedin.com/in/stevetheodore" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-github" href="https://github.com/theodox" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-google" href="https://plus.google.com/u/0/+SteveTheodore480BC/posts" target="_blank"><i class="fa fa-google"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/1936075/theodox" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id="Porting-Spelchek-to-Boo-">Porting Spelchek to Boo</h1>
    <p>Posted on Sat 06 June 2015 in <a href="./category/blog.html">blog</a></p>
  </header>
  <div>
    <hr />
<p>What could be more ghostly than a <em>post mortem?</em>  </p>
<p>If <a href="http://techartsurvival.blogspot.com/2015/05/boo-who.html">my last post about Boo</a> piqued your interest, but you haven’t had time to do a deep dive into the language to see for yourself, I’ve posted a version of the <a href="https://github.com/theodox/spelchek">Spelchek</a> Python spell checker module converted to Boo so you can see the similarities and differences between the two languages. <br />
The original Python version is <a href="https://github.com/theodox/spelchek/issues">here</a> and the Boo port is <a href="https://github.com/theodox/BooSpell">here</a>. As a good indication of what I’ve been saying about the economy of Boo syntax, the Boo version comes in at almost the same size as the Python original (5.05 kb for Boo and 4.95kb for Python) and pretty much the same number of lines – I haven’t done the excersize of converting it to C# for comparison but I’d guess the C# version would come in at about half again as much typing.<br />
Looking at the code, significant chunks are almost identical: the logic is pretty much the same and the type annotations are the only real difference. <br />
Thus  </p>
<div class="highlight"><pre><span></span>def add(word as string, pri as int):  
    &quot;&quot;&quot;  
    Adds &lt;word&gt; to the dictionary with the specified priority.   
    &quot;&quot;&quot;  
    _DICTIONARY[word.ToLower()] = pri
</pre></div>


<p>becomes   </p>
<div class="highlight"><pre><span></span>def add(word, priority=4):  
&quot;&quot;&quot;  
Adds &lt;word&gt; to the dictionary with the specified priority (default is 4)  
&quot;&quot;&quot;  
    _DICTIONARY[word.lower().strip()] = priority
</pre></div>


<p>which is pretty much identical.<br />
The tricky bit of the conversion was the routine which generates possible variants of the word - it generates variants of a word by transposition and deletions. In Python:  </p>
<div class="highlight"><pre><span></span>def first_order_variants(word):  
    &quot;&quot;&quot;  
    return the obvious spelling variants of &lt;word&gt; with missing words, transpositions, or misplaced characters  
    &quot;&quot;&quot;  
    splits = [(word[:i], word[i:]) for i in range(len(word) + 1)]  
    deletes = [a + b[1:] for a, b in splits if b]  
    transposes = [a + b[1] + b[0] + b[2:] for a, b in splits if len(b) &gt; 1]  
    replaces = [a + c + b[1:] for a, b in splits for c in _ALPHABET if b]  
    inserts = [a + c + b for a, b in splits for c in _ALPHABET]  
    return set(deletes + transposes + replaces + inserts)
</pre></div>


<p>As you can see the first list comprehension, <code>splits</code>, generates a lists of pairs representing places where the word could be broken up, so that ‘cat’ produces <code>[("c","at"), ("ca", "t")]</code>. The other comprehensions use that list to try inserting, deleting or transposing letters to guess what the user might have really been typing.<br />
In Boo, the tricky bit was getting the compiler to recognize that the <code>splits</code> list contained a pair of strings and that all the lists produced by it would also be lists of strings. Porting the python code directly wouldn’t work because Boo would see <code>splits</code> as a list of type <code>object</code> instead of deducing that it was a set of string pairs. <br />
Here’s the Boo version, which as you can see is recognizably the same but is clunkier than the Python, due to the need for typing,   </p>
<div class="highlight"><pre><span></span><span class="n">def</span> <span class="nf">first_order_variants</span><span class="p">(</span><span class="n">word</span> <span class="n">as</span> <span class="n">string</span><span class="p">)</span><span class="o">:</span>  
<span class="s">&quot;&quot;&quot;  </span>
<span class="k">return</span> <span class="n">the</span> <span class="n">obvious</span> <span class="n">spelling</span> <span class="n">variants</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">word</span><span class="o">&gt;</span> <span class="n">with</span> <span class="n">missing</span> <span class="n">words</span><span class="p">,</span> <span class="n">transpositions</span><span class="p">,</span> <span class="n">or</span> <span class="n">misplaced</span> <span class="n">characters</span>  
<span class="s">&quot;&quot;&quot;  </span>
    <span class="n">_stringList</span> <span class="o">=</span> <span class="n">Boo</span><span class="p">.</span><span class="n">Lang</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="n">of</span> <span class="p">(</span><span class="n">string</span><span class="p">)]</span>  
    <span class="n">_strings</span> <span class="o">=</span> <span class="n">Boo</span><span class="p">.</span><span class="n">Lang</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="n">of</span> <span class="n">string</span><span class="p">]</span>  
    <span class="n">pair</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span> <span class="n">as</span> <span class="n">string</span><span class="p">,</span> <span class="n">i</span> <span class="n">as</span> <span class="kt">int</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">:</span><span class="n">i</span><span class="p">]</span> <span class="n">cast</span> <span class="n">string</span><span class="p">,</span> <span class="n">w</span><span class="p">[</span><span class="nl">i</span><span class="p">:]</span> <span class="n">cast</span> <span class="n">string</span><span class="p">)}</span>  
    <span class="n">splits</span> <span class="o">=</span> <span class="n">_stringList</span><span class="p">((</span><span class="n">pair</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>  
    <span class="n">deletes</span>  <span class="o">=</span> <span class="n">_strings</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="n">as</span> <span class="n">string</span><span class="p">,</span> <span class="n">b</span> <span class="n">as</span> <span class="n">string</span> <span class="k">in</span> <span class="n">splits</span> <span class="k">if</span> <span class="n">b</span><span class="p">))</span>  
    <span class="n">transposes</span>  <span class="o">=</span> <span class="n">_strings</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="n">as</span> <span class="n">string</span><span class="p">,</span> <span class="n">b</span> <span class="n">as</span> <span class="n">string</span> <span class="k">in</span> <span class="n">splits</span> <span class="k">if</span> <span class="n">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>  
    <span class="n">replaces</span>  <span class="o">=</span> <span class="n">_strings</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="n">as</span> <span class="n">string</span><span class="p">,</span> <span class="n">b</span> <span class="n">as</span> <span class="n">string</span> <span class="k">in</span> <span class="n">splits</span> <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">_ALPHABET</span> <span class="k">if</span> <span class="n">b</span><span class="p">))</span>  
    <span class="n">inserts</span>  <span class="o">=</span> <span class="n">_strings</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="n">as</span> <span class="n">string</span><span class="p">,</span> <span class="n">b</span> <span class="n">as</span> <span class="n">string</span> <span class="k">in</span> <span class="n">splits</span> <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="n">_ALPHABET</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">HashSet</span><span class="p">[</span><span class="n">of</span> <span class="n">string</span><span class="p">]()</span>  
    <span class="k">for</span> <span class="n">chunk</span> <span class="k">in</span> <span class="p">(</span><span class="n">deletes</span><span class="p">,</span> <span class="n">transposes</span><span class="p">,</span> <span class="n">replaces</span><span class="p">,</span> <span class="n">inserts</span><span class="p">)</span><span class="o">:</span>  
        <span class="n">result</span><span class="p">.</span><span class="n">UnionWith</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>


<p>To clean it up I added two ‘aliases’ up at the top, since the Boo syntax for declaring typed containers is hard to read (‘List[of string]’): so <code>_stringList</code> is a shortcut for ‘list of string arrays’ and <code>_strings</code> is a shortcut for ‘list of strings’.<br />
The variable <code>pair</code> contains a lambda (ie, an inline function) using Boo’s idiosyncratic syntax: you could mentally rewrite it as  </p>
<div class="highlight"><pre><span></span>def pair(w as string, i as int) of (string):  
    return (w[:i], w(i:))
</pre></div>


<p>or in other words “give me a string and an integer, I’ll return a pair of strings split at the index you gave me.” <br />
With those helpers in place the logic is identical, but it is harder to follow because of all the type-mongering. I’m pretty sure there are more elegant ways to do this withgout being so wordy, but I’m not an expert.   </p>
<h1><a href="https://www.blogger.com/blogger.g?blogID=3596910715538761404&amp;bpli=1&amp;pli=1#so"></a>So…</h1>
<p>The point of the experiment was to see how hard the Python &gt; Boo translation would be. This is an application where types actually matter a good deal, since all my values are strings and I need to be able to do string operations like joins on them – if all I was doing as asking questions of them things would have been more Pythonic (though probably slower as well: one of the reasons we need those types is to get the compiler to help us speed the code up). <br />
While this is hardly a demanding application, it is at least a proof-of-concept for the idea of prototyping in Python and then selectively porting to Boo isn’t completely nuts.</p>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>
</article>

    <footer>
        <p>&copy; Steve Theodore </p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Porting Spelchek to Boo",
  "headline": "Porting Spelchek to Boo",
  "datePublished": "2015-06-06 22:13:00-07:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Steve Theodore",
    "url": "./author/steve-theodore.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "./Porting-Spelchek-to-Boo-.html",
  "description": "pending"
}
</script></body>
</html>