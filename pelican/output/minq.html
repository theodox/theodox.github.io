<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="./theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="./theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="stevet">
  <meta name="description" content="Posts and writings by stevet">

  <link href="/atom/%s_all.atom.xml" type="application/atom+xml" rel="alternate" title="static_site_test Atom" />

<meta name="keywords" content="blog, maya, programming, python">

  <title>
    static_site_test
&ndash; minq  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href=".">
        <img src="./theme/images/logo.png" alt="logo">
      </a>
      <h2><a href=".">stevet</a></h2>
      <p></p>
      <ul>
        <li><a href="http://getpelican.com/" target="_blank">Pelican</a></li>
        <li><a href="http://python.org/" target="_blank">Python.org</a></li>
        <li><a href="http://jinja.pocoo.org/" target="_blank">Jinja2</a></li>
        <li><a href="#" target="_blank">You can modify those links in your config file</a></li>
        <li><a href="#" target="_blank">You can add links in your config file</a></li>
        <li><a href="#" target="_blank">Another social link</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href=".">Index</a> &brvbar; <a href="./archives.html">Archives</a>
      &brvbar; <a href="/atom/%s_all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h3><a href="./minq.html">minq</a></h3>
  </div>
  <div class="article_text">
    <p>If you're a long-time reader, you may recall that i'm very ambivalent about <a href="http://techartsurvival.blogspot.com/2015/07/blockquote-background-f9f9f9-border.html">wrapper code</a>.  I'm just as prone to adding my own little spoonful of syntax sugar on top of my daily tasks, but I've also been around long enough to be a bit cynical about my own various faddisms and dubious style choices over the years.  Sure, extra typing is annoying -- but nowadays I tend to set a pretty high bar for actually writing wrapper code instead of just, ya know, doing my actual <em>job</em>.</p>
<p>So, it's with a little bit of trepidation that I'm sharing my latest library.  <strong><a href="https://github.com/theodox/minq">Minq</a></strong> bills itself as 'a query language for Maya scenes.'  The goal is to simplify a very common task for Maya coders: finding things in a scene.</p>
<p>Now, that isn't a particularly interesting job most of the time, but it's one we do a <em>lot</em>:  a quick grep of my own codebase shows over 600 calls to <code>cmds.ls()</code>, <code>cmds.listRelatives()</code>, <code>cmds.listHistory</code>  and <code>cmds.nodeType()</code> in various combinations: as far as I can tell, <code>ls()</code> is actually the single most common call I make.  </p>
<p>Moreover, I'm reasonably certain (though I didn't do the grepping to bear this out) that those hundreds of <code>ls()</code> calls are accompanied by hundreds of little snippets of code to deal with Maya's quirks.  How often have you run into little gems like this?</p>
<div class="highlight"><pre><span></span>    <span class="n">stuff</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;something_thats_not_transform&#39;</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="o">*</span><span class="n">stuff</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;transform&#39;</span><span class="p">)</span>
    <span class="c1"># [u&#39;top&#39;]</span>

    <span class="n">stuff</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">print</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="o">*</span><span class="n">stuff</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;transform&#39;</span><span class="p">)</span>
    <span class="c1"># [u&#39;front&#39;, u&#39;persp&#39;, u&#39;side&#39;, u&#39;top&#39;]</span>
</pre></div>


<p>or this?</p>
<div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">my_meshes</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;mesh&#39;</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">item</span>
    <span class="c1"># Error: &#39;NoneType&#39; object is not iterable</span>
    <span class="c1"># Traceback (most recent call last):</span>
    <span class="c1">#   File &quot;&lt;maya console&gt;&quot;, line 1, in &lt;module&gt;</span>
    <span class="c1"># TypeError: &#39;NoneType&#39; object is not iterable # </span>
</pre></div>


<p>There are of course ways around these little gotchas - but given the number of times you have to interact with them it's hard to be sure you've really nailed them all. In my case a 99% correct handlong of my <code>ls()</code> calls alone will produce at least 5 bugs.</p>
<p>More importantly -- and, frankly, the whole reason for this project -- dealing with these little gotchas is not an <em>interesting</em> job.  Finding, filter and sorting stuff in your Maya scene is not am opportunity for you to display your brilliant algorithms or clever strategies for bending Maya to your will: it's just a bunch of stuff you have to on your way to fixing the problems your users really want fixed.</p>
<h2>Minq in action</h2>
<p>Hence, <a href="https://github.com/theodox/minq">minq</a>. </p>
<p>The goal of minq is to provide a more concise and more readable way to find things in your maya scenes.  Here's an example to give you the idea of how the project is supposed to work.</p>
<p>Suppose you need to find all of your character skeletons and distinguish them from other things lying around in the scene.  The easy way to do that is usually to look for assemblies (top level nodes) which have children who drive skinClusters.  Here's an example of how you could find all the root nodes in the scene which drive skins using conventional means:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_assemblies_that_drive_skins</span><span class="p">():</span>
    <span class="n">skinned</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">asm</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">assemblies</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[]:</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">listRelatives</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="n">ad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="n">history</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">listHistory</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">future</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">history</span> <span class="ow">and</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;skinCluster&#39;</span><span class="p">):</span>
            <span class="n">skinned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">skinned</span>
</pre></div>


<p>You'll notice the littering of <code>or []</code> to make sure we don't get errors for failed queries, and also the.  We have to create two temporary variables (<code>childen</code> and <code>history</code>)  in order to store the intermediate results.  And we're 3 layers deep when we get to  the actual work item. </p>
<p>Above all, though, you need to remember two little bits of Maya trivia to make sense of this code: that <code>cmds.ls(asm=True)</code> means 'give me the assemblies' and that <code>listRelatives(ad=True)</code> gives you the children of an object. These are, of course, very clear to Maya vets -- but there are over 50 flags in <code>ls()</code> and more than a dozen in <code>listRelatives()</code> .  I've been working in Maya for 20 years and I still need to look up most of them.  You pass those flags to Maya as strings which won't get evaluated until runtime -- and it's possible to mistype them and not even know because <code>ls()</code>, in particular, makes wierd tweaky decisions about how to interpret conflicting flags.</p>
<p>Here's the minq equivalent to the previous function:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">drives_skin</span><span class="p">(</span><span class="n">some_object</span><span class="p">):</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">using</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">AllChildren</span><span class="p">)</span>
    <span class="n">skin_clusters</span> <span class="o">=</span> <span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Future</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="n">SkinClusters</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">skin_clusters</span><span class="p">)</span>

<span class="n">unskinned_assemblies</span> <span class="o">=</span> <span class="n">Assemblies</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">drives_skin</span><span class="p">)</span>
</pre></div>


<p>It's shorter, obviously, but the real goal here is readability first. Here's what happens, which should be pretty clear from the names:
1.  <code>drives_skin()</code> takes a maya object
2.  It gets all of that object's children
3.  It gets all of the future history of those children
4.  It it filters down to only the skin clusters in that future history
5.  it returns true if any skin clusters are present</p>
<p>The rest of it pretty self evident: <code>unskinned_assemblies</code> just collects all of the assemblies which pass <code>drives_skin()</code>.  The <em>algorithm</em> is exactly the same as the first version -- but, at least to me, that algorithm is actually expressed much more clearly in the minq version. </p>
<p>A purist will probably point out that there are important under-the-hood details in the first one that are hidden in the second, and s/he'd be right.  However after doing a lot of this kind of code down the years I'm fairly certain that those important details have almost always been important because screwing them up causes problems -- not because they provide an opportunity for a wizardly optimization or better approach to the problem.  I'm interested in finding unskinned meshes, not in remembering to pass the correct flags to <code>ls</code>  and <code>listRelatives</code>.</p>
<p>Here's a couple of other examples to give you the flavor of what a minq query looks like:</p>
<div class="highlight"><pre><span></span><span class="c1"># get all mesh transforms in a scene</span>
<span class="n">mesh_transforms</span> <span class="o">=</span>  <span class="n">Meshes</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Parents</span><span class="p">)</span>

<span class="c1"># find stub joints</span>
<span class="k">def</span> <span class="nf">is_stub</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span> <span class="p">(</span><span class="n">using</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Children</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="n">Transforms</span><span class="p">))</span>
<span class="n">stubs</span> <span class="o">=</span> <span class="n">Joints</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_stub</span><span class="p">)</span>

<span class="c1"># filtering by type, by name, and with functions</span>
<span class="n">cube_creator_nodes</span> <span class="o">=</span> <span class="n">PolyCreators</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s1">&#39;polyCube&#39;</span><span class="p">)</span>
<span class="n">used_to_be_cubes</span> <span class="o">=</span> <span class="n">cube_creator_nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Future</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="n">Meshes</span><span class="p">)</span>
<span class="n">has_8_verts</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">cmds</span><span class="o">.</span><span class="n">polyEvaluate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span>
<span class="n">still_are_cubes</span> <span class="o">=</span> <span class="n">used_to_be_cubes</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">has_8_verts</span><span class="p">)</span>

<span class="c1"># adding, subtracting or intersecting queries</span>

<span class="n">too_high</span> <span class="o">=</span> <span class="n">Transforms</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">ty</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">too_low</span> <span class="o">=</span> <span class="n">Transforms</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">ty</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">)</span>

<span class="n">middle_xforms</span> <span class="o">=</span> <span class="n">Transforms</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">too_high</span> <span class="o">+</span> <span class="n">too_low</span><span class="p">)</span>
</pre></div>


<p>So, that's the basic idea:  to replace a lot of tedious boilerplate with something a little cleaner, more predictable and easier to maintain.  The code for the whole thing is up on <a href="https://github.com/theodox/minq">up on Github</a> under the usual MIT, 'use it as you like but keep the copyright header' license. It's still very much a work-in-progress and I'd love feedback, particularly on issues of syntax and style.  </p>
  </div>
  <div class="article_meta">
    <p>Posted on: Thu 01 January 2015</p>
    <p>Category: <a href="./category/blog.html">Blog</a>
 &ndash; Tags:
      <a href="./tag/blog.html">blog</a>,      <a href="./tag/maya.html">maya</a>,      <a href="./tag/programming.html">programming</a>,      <a href="./tag/python.html">python</a>    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; stevet. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>