<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="./theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="./theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="stevet">
  <meta name="description" content="Posts and writings by stevet">

  <link href="/atom/%s_all.atom.xml" type="application/atom+xml" rel="alternate" title="static_site_test Atom" />

<meta name="keywords" content="">

  <title>
    static_site_test
&ndash; A touch of minq  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href=".">
        <img src="./theme/images/logo.png" alt="logo">
      </a>
      <h2><a href=".">stevet</a></h2>
      <p></p>
      <ul>
        <li><a href="http://getpelican.com/" target="_blank">Pelican</a></li>
        <li><a href="http://python.org/" target="_blank">Python.org</a></li>
        <li><a href="http://jinja.pocoo.org/" target="_blank">Jinja2</a></li>
        <li><a href="#" target="_blank">You can modify those links in your config file</a></li>
        <li><a href="#" target="_blank">You can add links in your config file</a></li>
        <li><a href="#" target="_blank">Another social link</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href=".">Index</a> &brvbar; <a href="./archives.html">Archives</a>
      &brvbar; <a href="/atom/%s_all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h3><a href="./A-touch-of-minq.html">A touch of minq</a></h3>
  </div>
  <div class="article_text">
    <p>If you’re a long-time reader, you may recall that i’m very ambivalent about <a href="http://techartsurvival.blogspot.com/2015/07/blockquote-background-f9f9f9-border.html">wrapper code</a>. I’m just as prone to adding my own little spoonful of syntax sugar on top of my daily tasks, but I’ve also been around long enough to be a bit cynical about my own various faddisms and dubious style choices over the years. Sure, extra typing is annoying – but nowadays I tend to set a pretty high bar for actually writing wrapper code instead of just, ya know, doing my actual <em>job</em>.<br />
So, it’s with a little bit of trepidation that I’m sharing my latest library. <strong><a href="https://github.com/theodox/minq">Minq</a></strong> bills itself as ‘a query language for Maya scenes.’ The goal is to simplify a very common task for Maya coders: finding things in a scene.<br />
Now, that isn’t a particularly interesting job most of the time, but it’s one we do a <em>lot</em>: a quick grep of my own codebase shows over 600 calls to <code>cmds.ls()</code>, <code>cmds.listRelatives()</code>, <code>cmds.listHistory</code> and <code>cmds.nodeType()</code> in various combinations: as far as I can tell, <code>ls()</code> is actually the single most common call I make. <br />
Moreover, I’m reasonably certain (though I didn’t do the grepping to bear this out) that those hundreds of <code>ls()</code> calls are accompanied by hundreds of little snippets of code to deal with Maya’s quirks. How often have you run into little gems like this?  </p>
<div class="highlight"><pre><span></span>    stuff = [&#39;top&#39;, &#39;something_thats_not_transform&#39;]  
    print cmds.ls(*stuff, type=&#39;transform&#39;)  
    # [u&#39;top&#39;]

    stuff = []  
    print cmds.ls(*stuff, type=&#39;transform&#39;)  
    # [u&#39;front&#39;, u&#39;persp&#39;, u&#39;side&#39;, u&#39;top&#39;]
</pre></div>


<p>or this?  </p>
<div class="highlight"><pre><span></span>    for item in cmds.ls(my_meshes, type=&#39;mesh&#39;):  
        print item  
    # Error: &#39;NoneType&#39; object is not iterable  
    # Traceback (most recent call last):  
    #   File &quot;&lt;maya console&gt;&quot;, line 1, in &lt;module&gt;  
    # TypeError: &#39;NoneType&#39; object is not iterable #
</pre></div>


<p>There are of course ways around these little gotchas - but given the number of times you have to interact with them it’s hard to be sure you’ve really nailed them all. In my case a 99% correct handlong of my <code>ls()</code> calls alone will produce at least 5 bugs.<br />
More importantly – and, frankly, the whole reason for this project – dealing with these little gotchas is not an <em>interesting</em> job. Finding, filter and sorting stuff in your Maya scene is not am opportunity for you to display your brilliant algorithms or clever strategies for bending Maya to your will: it’s just a bunch of stuff you have to on your way to fixing the problems your users really want fixed.  </p>
<h2><a href="https://www.blogger.com/blogger.g?blogID=3596910715538761404#minq-in-action"></a>Minq in action</h2>
<p>Hence, <a href="https://github.com/theodox/minq">minq</a>. <br />
The goal of minq is to provide a more concise and more readable way to find things in your maya scenes. Here’s an example to give you the idea of how the project is supposed to work.<br />
Suppose you need to find all of your character skeletons and distinguish them from other things lying around in the scene. The easy way to do that is usually to look for assemblies (top level nodes) which have children who drive skinClusters. Here’s an example of how you could find all the root nodes in the scene which drive skins using conventional means:  </p>
<div class="highlight"><pre><span></span>def find_assemblies_that_drive_skins():  
    skinned = []  
    for asm in cmds.ls(assemblies=True) or []:  
        children = cmds.listRelatives(asm, ad=True) or []  
        history = cmds.listHistory(children, future=True)  
        if history and cmds.ls(history, type=&#39;skinCluster&#39;):  
            skinned.append(asm)  
    return skinned
</pre></div>


<p>You’ll notice the littering of <code>or []</code> to make sure we don’t get errors for failed queries. We have to create two temporary variables (<code>childen</code> and <code>history</code>) in order to store the intermediate results. And, obviously, we’re 3 layers deep when we get to the actual work item. <br />
Above all, though, you need to remember two little bits of Maya trivia to make sense of this code: that <code>cmds.ls(asm=True)</code> means ‘give me the assemblies’ and that <code>listRelatives(ad=True)</code> gives you the children of an object. These are, of course, very clear to Maya vets – but there are over 50 flags in <code>ls()</code> and more than a dozen in <code>listRelatives()</code> . I’ve been working in Maya for 20 years and I still need to look up most of them. You pass those flags to Maya as strings which won’t get evaluated until runtime – and it’s possible to mistype them and not even know because <code>ls()</code>, in particular, makes wierd tweaky decisions about how to interpret conflicting flags.<br />
Here’s the minq equivalent to the previous function:  </p>
<div class="highlight"><pre><span></span>def drives_skin(some_object):  
    children = using(some_object).get(AllChildren)  
    skin_clusters = children.get(Future).only(SkinClusters)  
    return any(skin_clusters)

unskinned_assemblies = Assemblies().where(drives_skin)
</pre></div>


<p>It’s shorter, but the real goal is to make it more readable. Here’s what happens, which should be pretty clear from the names:<br />
1. <code>drives_skin()</code> takes a maya object<br />
2. It gets all of that object’s children<br />
3. It gets all of the future history of those children<br />
4. It it filters down to only the skin clusters in that future history<br />
5. it returns true if any skin clusters are present<br />
The rest of it pretty self evident: <code>unskinned_assemblies</code> just collects all of the assemblies which pass <code>drives_skin()</code>. The <em>algorithm</em> is exactly the same as the first version – but, at least to me, that algorithm is actually expressed much more clearly in the minq version. As for concision, I deliberately broke the query into two lines to make it easier to read -- otherwise it could all be done in a single expression.<br />
A purist will probably point out that there are important under-the-hood details in the first one that are hidden in the second, and s/he’d be right. However after doing a lot of this kind of code down the years I’m fairly certain that those important details have almost always been important because screwing them up causes problems – not because they provide an opportunity for a wizardly optimization or better approach to the problem. I’m interested in finding unskinned meshes, not in remembering to pass the correct flags to <code>ls</code> and <code>listRelatives</code>.<br />
Here’s a couple of other examples to give you the flavor of what a minq query looks like:  </p>
<div class="highlight"><pre><span></span># get all mesh transforms in a scene  
mesh_transforms =  Meshes().get(Parents)

# find stub joints  
def is_stub(obj):  
    return not any (using(obj).get(Children).only(Transforms))  
stubs = Joints().where(is_stub)

# filtering by type, by name, and with functions  
cube_creator_nodes = PolyCreators().only(&#39;polyCube&#39;)  
used_to_be_cubes = cube_creator_nodes.get(Future).only(Meshes)  
has_8_verts = lambda p: cmds.polyEvaluate(p, v=True) == 8  
still_are_cubes = used_to_be_cubes.where(has_8_verts)

# adding, subtracting or intersecting queries

too_high = Transforms().where(item.ty &gt; 100)  
too_low = Transforms().where(item.ty &lt; -100)

middle_xforms = Transforms() - (too_high + too_low)
</pre></div>


<p>So, that’s the basic idea: to replace a lot of tedious boilerplate with something a little cleaner, more predictable and easier to maintain. The code for the whole thing is up on <a href="https://github.com/theodox/minq">up on Github</a> under the usual MIT, ‘use it as you like but keep the copyright header’ license. It’s still very much a work-in-progress and I’d love feedback, particularly on issues of syntax and style. </p>
  </div>
  <div class="article_meta">
    <p>Posted on: Sun 06 March 2016</p>
    <p>Category: <a href="./category/blog.html">blog</a>
    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; stevet. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>