<!DOCTYPE html>
<html lang="en">
<head>
          <title>Chimeras & Manticores</title>
        <meta charset="utf-8" />
        <link href="http://theodox.com/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Chimeras & Manticores Full Atom Feed" />
        <link href="http://theodox.com/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="Chimeras & Manticores Full RSS Feed" />



    <meta name="tags" content="python" />
    <meta name="tags" content="maya" />
    <meta name="tags" content="programming" />
    <meta name="tags" content="minq" />

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://theodox.com/">Chimeras & Manticores <strong>technical art, python, the games business, and obscurantism</strong></a></h1>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
            <li><a href="/about">About...</a></li>
            <li><a href="/pages/pub">Publications</a></li>
            <li><a href="http://astore.amazon.com/tecsurgui-20">Tech-Art Book Store</a></li>
            <li><a href="/pages/cookbook">Cookbook</a></li>
        </ul></nav><!-- /#menu -->
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://theodox.com/2016/a_touch_of_minq" rel="bookmark"
         title="Permalink to A touch of minq">A touch of&nbsp;minq</a></h2>
 
  </header>
  <footer class="post-info">
    <abbr class="published" title="2016-03-06T09:02:00.001000-08:00">
      Sun 06 March 2016
    </abbr>
    <address class="vcard author">
      By           <a class="url fn" href="http://theodox.com/author/steve-theodore.html">Steve Theodore</a>
    </address>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <p>If you’re a long-time reader, you may recall that i’m very ambivalent about <a href="wraptastic.html">wrapper code</a>. I’m just as prone to adding my own little spoonful of syntax sugar on top of my daily tasks, but I’ve also been around long enough to be a bit cynical about my own various faddisms and dubious style choices over the years. Sure, extra typing is annoying – but nowadays I tend to set a pretty high bar for actually writing wrapper code instead of just, ya know, doing my actual <em>job</em>.<br />
So, it’s with a little bit of trepidation that I’m sharing my latest library. <strong><a href="https://github.com/theodox/minq">Minq</a></strong> bills itself as ‘a query language for Maya scenes.’ The goal is to simplify a very common task for Maya coders: finding things in a scene.<br />
Now, that isn’t a particularly interesting job most of the time, but it’s one we do a <em>lot</em>: a quick grep of my own codebase shows over 600 calls to <code>cmds.ls()</code>, <code>cmds.listRelatives()</code>, <code>cmds.listHistory</code> and <code>cmds.nodeType()</code> in various combinations: as far as I can tell, <code>ls()</code> is actually the single most common call I make. <br />
Moreover, I’m reasonably certain (though I didn’t do the grepping to bear this out) that those hundreds of <code>ls()</code> calls are accompanied by hundreds of little snippets of code to deal with Maya’s quirks. How often have you run into little gems like&nbsp;this?  </p>
<div class="highlight"><pre><span></span><span class="n">stuff</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;something_thats_not_transform&#39;</span><span class="p">]</span>  
<span class="k">print</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="o">*</span><span class="n">stuff</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;transform&#39;</span><span class="p">)</span>  
<span class="c1"># [u&#39;top&#39;]</span>

<span class="n">stuff</span> <span class="o">=</span> <span class="p">[]</span>  
<span class="k">print</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="o">*</span><span class="n">stuff</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;transform&#39;</span><span class="p">)</span>  
<span class="c1"># [u&#39;front&#39;, u&#39;persp&#39;, u&#39;side&#39;, u&#39;top&#39;]</span>
</pre></div>


<p>or&nbsp;this?  </p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">my_meshes</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;mesh&#39;</span><span class="p">):</span>  
    <span class="k">print</span> <span class="n">item</span>  
<span class="c1"># Error: &#39;NoneType&#39; object is not iterable  </span>
<span class="c1"># Traceback (most recent call last):  </span>
<span class="c1">#   File &quot;&lt;maya console&gt;&quot;, line 1, in &lt;module&gt;  </span>
<span class="c1"># TypeError: &#39;NoneType&#39; object is not iterable #</span>
</pre></div>


<p>There are of course ways around these little gotchas - but given the number of times you have to interact with them it’s hard to be sure you’ve really nailed them all. In my case a 99% correct handlong of my <code>ls()</code> calls alone will produce at least 5 bugs.<br />
More importantly – and, frankly, the whole reason for this project – dealing with these little gotchas is not an <em>interesting</em> job. Finding, filter and sorting stuff in your Maya scene is not am opportunity for you to display your brilliant algorithms or clever strategies for bending Maya to your will: it’s just a bunch of stuff you have to on your way to fixing the problems your users really want&nbsp;fixed.  </p>
<h2>Minq in&nbsp;action</h2>
<p>Hence, <a href="https://github.com/theodox/minq">minq</a>. <br />
The goal of minq is to provide a more concise and more readable way to find things in your maya scenes. Here’s an example to give you the idea of how the project is supposed to work.<br />
Suppose you need to find all of your character skeletons and distinguish them from other things lying around in the scene. The easy way to do that is usually to look for assemblies (top level nodes) which have children who drive skinClusters. Here’s an example of how you could find all the root nodes in the scene which drive skins using conventional&nbsp;means:  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_assemblies_that_drive_skins</span><span class="p">():</span>  
    <span class="n">skinned</span> <span class="o">=</span> <span class="p">[]</span>  
    <span class="k">for</span> <span class="n">asm</span> <span class="ow">in</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">assemblies</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[]:</span>  
        <span class="n">children</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">listRelatives</span><span class="p">(</span><span class="n">asm</span><span class="p">,</span> <span class="n">ad</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[]</span>  
        <span class="n">history</span> <span class="o">=</span> <span class="n">cmds</span><span class="o">.</span><span class="n">listHistory</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">future</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
        <span class="k">if</span> <span class="n">history</span> <span class="ow">and</span> <span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;skinCluster&#39;</span><span class="p">):</span>  
            <span class="n">skinned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asm</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">skinned</span>
</pre></div>


<p>You’ll notice the littering of <code>or []</code> to make sure we don’t get errors for failed queries. We have to create two temporary variables (<code>childen</code> and <code>history</code>) in order to store the intermediate results. And, obviously, we’re 3 layers deep when we get to the actual work item. <br />
Above all, though, you need to remember two little bits of Maya trivia to make sense of this code: that <code>cmds.ls(asm=True)</code> means ‘give me the assemblies’ and that <code>listRelatives(ad=True)</code> gives you the children of an object. These are, of course, very clear to Maya vets – but there are over 50 flags in <code>ls()</code> and more than a dozen in <code>listRelatives()</code> . I’ve been working in Maya for 20 years and I still need to look up most of them. You pass those flags to Maya as strings which won’t get evaluated until runtime – and it’s possible to mistype them and not even know because <code>ls()</code>, in particular, makes wierd tweaky decisions about how to interpret conflicting flags.<br />
Here’s the minq equivalent to the previous&nbsp;function:  </p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">drives_skin</span><span class="p">(</span><span class="n">some_object</span><span class="p">):</span>  
    <span class="n">children</span> <span class="o">=</span> <span class="n">using</span><span class="p">(</span><span class="n">some_object</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">AllChildren</span><span class="p">)</span>  
    <span class="n">skin_clusters</span> <span class="o">=</span> <span class="n">children</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Future</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="n">SkinClusters</span><span class="p">)</span>  
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">skin_clusters</span><span class="p">)</span>

<span class="n">unskinned_assemblies</span> <span class="o">=</span> <span class="n">Assemblies</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">drives_skin</span><span class="p">)</span>
</pre></div>


<p>It’s shorter, but the real goal is to make it more readable. Here’s what happens, which should be pretty clear from the&nbsp;names:  </p>
<ol>
<li><code>drives_skin()</code> takes a maya&nbsp;object  </li>
<li>It gets all of that object’s&nbsp;children  </li>
<li>It gets all of the future history of those&nbsp;children  </li>
<li>It it filters down to only the skin clusters in that future&nbsp;history  </li>
<li>it returns true if any skin clusters are&nbsp;present  </li>
</ol>
<p>The rest of it pretty self evident: <code>unskinned_assemblies</code> just collects all of the assemblies which pass <code>drives_skin()</code>. The <em>algorithm</em> is exactly the same as the first version – but, at least to me, that algorithm is actually expressed much more clearly in the minq version. As for concision, I deliberately broke the query into two lines to make it easier to read &#8212; otherwise it could all be done in a single expression.<br />
A purist will probably point out that there are important under-the-hood details in the first one that are hidden in the second, and s/he’d be right. However after doing a lot of this kind of code down the years I’m fairly certain that those important details have almost always been important because screwing them up causes problems – not because they provide an opportunity for a wizardly optimization or better approach to the problem. I’m interested in finding unskinned meshes, not in remembering to pass the correct flags to <code>ls</code> and <code>listRelatives</code>.  </p>
<p>Here’s a couple of other examples to give you the flavor of what a minq query looks&nbsp;like:  </p>
<div class="highlight"><pre><span></span><span class="c1"># get all mesh transforms in a scene  </span>
<span class="n">mesh_transforms</span> <span class="o">=</span>  <span class="n">Meshes</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Parents</span><span class="p">)</span>

<span class="c1"># find stub joints  </span>
<span class="k">def</span> <span class="nf">is_stub</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>  
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span> <span class="p">(</span><span class="n">using</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Children</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="n">Transforms</span><span class="p">))</span>  
<span class="n">stubs</span> <span class="o">=</span> <span class="n">Joints</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_stub</span><span class="p">)</span>

<span class="c1"># filtering by type, by name, and with functions  </span>
<span class="n">cube_creator_nodes</span> <span class="o">=</span> <span class="n">PolyCreators</span><span class="p">()</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s1">&#39;polyCube&#39;</span><span class="p">)</span>  
<span class="n">used_to_be_cubes</span> <span class="o">=</span> <span class="n">cube_creator_nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">Future</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="n">Meshes</span><span class="p">)</span>  
<span class="n">has_8_verts</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">cmds</span><span class="o">.</span><span class="n">polyEvaluate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span>  
<span class="n">still_are_cubes</span> <span class="o">=</span> <span class="n">used_to_be_cubes</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">has_8_verts</span><span class="p">)</span>

<span class="c1"># adding, subtracting or intersecting queries</span>

<span class="n">too_high</span> <span class="o">=</span> <span class="n">Transforms</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">ty</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>  
<span class="n">too_low</span> <span class="o">=</span> <span class="n">Transforms</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">ty</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">100</span><span class="p">)</span>

<span class="n">middle_xforms</span> <span class="o">=</span> <span class="n">Transforms</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">too_high</span> <span class="o">+</span> <span class="n">too_low</span><span class="p">)</span>
</pre></div>


<p>So, that’s the basic idea: to replace a lot of tedious boilerplate with something a little cleaner, more predictable and easier to maintain. The code for the whole thing is up on <a href="https://github.com/theodox/minq">up on Github</a> under the usual <span class="caps">MIT</span>, ‘use it as you like but keep the copyright header’ license. It’s still very much a work-in-progress and I’d love feedback, particularly on issues of syntax and&nbsp;style. </p>
  </div><!-- /.entry-content -->
</section>
        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>